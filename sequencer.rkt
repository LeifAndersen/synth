#lang racket

(require math/array racket/flonum racket/unsafe/ops)

(require "synth.rkt")

(provide scale chord sequence mix)

(define (base+relative-semitone->freq base relative-semitone)
  (* 440 (expt (expt 2 1/12) -57)))

;; details at http://www.phy.mtu.edu/~suits/notefreqs.html
(define (note-freq note)
  ;; A4 (440Hz) is 57 semitones above C0, which is our base.
  (* 440 (expt (expt 2 1/12) (- note 57)))) 

;; A note is represented using the number of semitones from C0.
(define (name+octave->note name octave)
  (+ (* 12 octave)
     (case name
       [(C) 0] [(C# Db) 1] [(D) 2] [(D# Eb) 3]  [(E) 4] [(F) 5] [(F# Gb) 6]
       [(G) 7] [(G# Ab) 8] [(A) 9] [(A# Bb) 10] [(B) 11])))

;; Generates a scale of the given mode (major, minor, ...) starting at
;; `root' at `octave'. `duration' is the duration of an individual note.
;; Custom scales can be generated by giving a list of semitone intervals.
;; Returns a list of note + duration pairs
;; TODO add option for descending
(define (scale root octave duration mode . notes*)
  (define root-note (name+octave->note root octave))
  (define notes
    (if (eq? mode 'custom)
        notes
        (case mode
          ((major ionian)                '(0 2 4 5 7 9 11 12))
          ((minor minor-natural aeolian) '(0 2 3 5 7 8 10 12))
          ((minor-harmonic mohammedan)   '(0 2 3 5 7 8 11 12))
          ((minor-melodic)               '(0 2 3 5 7 9 11 12))
          ((dorian)                      '(0 2 3 5 7 9 10 12))
          ((phrygian)                    '(0 1 3 5 7 8 10 12))
          ((lydian)                      '(0 2 4 6 7 9 11 12))
          ((mixolydian)                  '(0 2 4 5 7 9 10 12))
          ((locrian)                     '(0 1 3 5 6 8 10 12))
          ((major-arpeggio)              '(0 4 7))
          ((minor-arpeggio)              '(0 3 7))
          ((custom)                      notes))))
  (for/list ([n (in-list notes)])
    (cons (+ root-note n) duration)))
;; TODO probably leave duration out of this (and chord) for now, and have it
;;  be part of a higher-level API

;; Similar to scale, but generates a chord.
;; Chords are pairs (listof note) + duration
(define (chord root octave duration type . notes*)
  (define notes (apply scale root octave duration type notes*))
  (cons (map car notes) duration))

;; Weighted sum of signals, receives a list of lists (signal weight).
;; Shorter signals are repeated to match the length of the longest.
;; Normalizes output to be within [-1,1].
;; TODO use structs for these things
(define (mix . ss)
  ;; To normalize, we downscale the signals by the sum of the weights.
  (define weights (for/list ([s (in-list ss)])
                    (exact->inexact (second s))))
  (define downscale-factor (apply + weights))
  ;; TODO original took ~39 secs, ~34 with loop fusion, ~32 with unsafe flonum ops, ~25 with more loop fusion
  ;;  -> how much of that is typed/untyped boundary?
  ;;  -> figure out how to automatically deforest, doing it by hand is silly
  ;; TODO profile. at this point, maybe `sequence' is the bottleneck
  (parameterize ([array-broadcasting 'permissive]) ; repeat short signals    
    (apply array-map
           (lambda xs
             (for/fold ([sum 0.0])
                 ([x (in-list xs)]
                  [w (in-list weights)])
               (unsafe-fl+ sum
                           (unsafe-fl* (unsafe-fl/ x downscale-factor) w))))
           (map first ss))))
;; TODO doesn't belong in sequencer.rkt. mixing.rkt?

;; repeats n times the sequence encoded by the pattern, at tempo bpm
;; pattern is a list of either single notes (note . duration) or
;; chords ((note ...) . duration) or pauses (#f . duration)
(define (sequence n pattern tempo function)
  ;; TODO for some reason, this causes memory to blow up
  ;; ;; simple preprocessing, if we have chords in the pattern, each note must be
  ;; ;; a chord (to solve normalization issues)
  ;; (when (foldl (lambda (x y) (or x (list? (car y)))) ;; TODO refactor
  ;;              #f
  ;;              pattern)
  ;;   (set! pattern (map (lambda (x)
  ;;                        (if (list? (car x))
  ;;                            x
  ;;                            `(((,(car  x) ,(cadr x)))
  ;;                              #f
  ;;                              ,(caddr x)))) ; construct a 1-note chord
  ;;                      pattern)))

  (define samples-per-beat (/ (* fs 60) tempo))
  (array-append*
   (for*/list ([i    (in-range n)] ; repeat the whole pattern
               [note (in-list  pattern)])
     (if (list? (car note)) ; chord
         (apply mix
                (map (lambda (x)
                       (list (sequence ;; TODO refactor
                               1
                               `((,x ; note
                                  . ,(cdr note))) ; duration
                               tempo function)
                             1)) ; all of equal weight
                     (car note)))
         (let ([f (if (car note)
                      (function (note-freq (car note)))
                      (lambda (x) 0.0))]) ; pause
           (build-array (vector (* samples-per-beat (cdr note))) f))))))

;; TODO try moving just the mixer to TR, to see if that's enough
;;   sequencer's the hard part to add types to
