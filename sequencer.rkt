#lang racket

(require math/array racket/flonum racket/unsafe/ops)

(require "synth.rkt")

(provide scale chord sequence mix)

;; for octave 0 (A4 is 440)
;; found at http://www.phy.mtu.edu/~suits/notefreqs.html
(define notes-frequencies
  '((C  . 16.35)
    (C# . 17.32)
    (Db . 17.32)
    (D  . 18.35)
    (D# . 19.45)
    (Eb . 19.45)
    (E  . 20.60)
    (F  . 21.83)
    (F# . 23.12)
    (Gb . 23.12)
    (G  . 24.50)
    (G# . 25.96)
    (Ab . 25.96)
    (A  . 27.50)
    (A# . 29.14)
    (Bb . 29.14)
    (B  . 30.87)))

(define (get-note-frequency note octave)
  (* (expt 2 octave) (dict-ref notes-frequencies note)))


;; TODO other design, store notes internally as the number of semitones from C0?

;; Generates a scale of the given mode (major, minor, ...) starting at
;; `root' at `octave'. `duration' is the duration of an individual note.
;; Custom scales can be generated by giving a list of semitone intervals.
;; TODO add option for descending
(define (scale root octave duration mode . notes)
  (define semitones
    ;; matching between semitones from C and note names
    '((0  . C)
      (1  . C#)
      (2  . D)
      (3  . D#)
      (4  . E)
      (5  . F)
      (6  . F#)
      (7  . G)
      (8  . G#)
      (9  . A)
      (10 . A#)
      (11 . B)))
  (define (inv-assq x l)
    (cond ((null? l)        #f)
          ((eq? (cdar l) x) (car l))
          (else             (inv-assq x (cdr l))))) ;; TODO bleh, get rid of
  (define (note->semitone note) (car (inv-assq note semitones)))
  (define root-semitone (note->semitone root))
  (define (semitone->note semitone) (dict-ref semitones semitone))
  (define (add-semitone n) ; returns root + n
    (define semitone (+ n root-semitone))
    (list (semitone->note (modulo semitone 12))
          (+ octave (quotient semitone 12))
          duration))
  (map add-semitone
       (case mode
         ((major ionian) '(0 2 4 5 7 9 11 12))
         ((minor minor-natural aeolian) '(0 2 3 5 7 8 10 12))
         ((minor-harmonic mohammedan) '(0 2 3 5 7 8 11 12))
         ((minor-melodic) '(0 2 3 5 7 9 11 12))
         ((dorian) '(0 2 3 5 7 9 10 12))
         ((phrygian) '(0 1 3 5 7 8 10 12))
         ((lydian) '(0 2 4 6 7 9 11 12))
         ((mixolydian) '(0 2 4 5 7 9 10 12))
         ((locrian) '(0 1 3 5 6 8 10 12))
         ((major-arpeggio) '(0 4 7))
         ((minor-arpeggio) '(0 3 7))
         ((custom) notes))))
;; TODO is this a good design? or should this return frequency/duration pairs?
;; TODO probably leave duration out of this (and chord) for now, and have it
;;  be part of a higher-level API

;; similar to scale, but generates a chord
(define (chord root octave duration type . notes)
  (let ([notes (apply scale `(,root ,octave ,duration ,type ,@notes))])
    (list (map (lambda (x) `(,(car x) ,(cadr x))) notes)
          #f
          duration))) ;; TODO refactor this

;; Weighted sum of signals, receives a list of lists (signal weight).
;; Shorter signals are repeated to match the length of the longest.
;; Normalizes output to be within [-1,1].
;; TODO use structs for these things
(define (mix . ss)
  ;; To normalize, we downscale the signals by the sum of the weights.
  (define weights (for/list ([s (in-list ss)])
                    (exact->inexact (second s))))
  (define downscale-factor (apply + weights))
  ;; TODO original took ~39 secs, ~34 with loop fusion, ~32 with unsafe flonum ops, ~25 with more loop fusion
  ;;  -> how much of that is typed/untyped boundary?
  ;;  -> figure out how to automatically deforest, doing it by hand is silly
  ;; TODO profile. at this point, maybe `sequence' is the bottleneck
  (parameterize ([array-broadcasting 'permissive]) ; repeat short signals    
    (apply array-map
           (lambda xs
             (for/fold ([sum 0.0])
                 ([x (in-list xs)]
                  [w (in-list weights)])
               (unsafe-fl+ sum
                           (unsafe-fl* (unsafe-fl/ x downscale-factor) w))))
           (map first ss))))
;; TODO doesn't belong in sequencer.rkt. mixing.rkt?

;; repeats n times the sequence encoded by the pattern, at tempo bpm
(define (sequence n pattern tempo function)
  ;; notes are represented by a list (note octave duration)
  ;; duration is in beats
  ;; ex : '(A 3 1)
  ;; pauses are represented as (#f #f duration)
  ;; chords can also be represented in patterns, in which case a list of notes
  ;; is found instead of a note
  ;; ex : '(((C 3) (E 3) (G 3)) #f 1)
  ;;  would give a major C chord on octave 3 of duration 1

  ;; TODO for some reason, this causes memory to blow up
  ;; ;; simple preprocessing, if we have chords in the pattern, each note must be
  ;; ;; a chord (to solve normalization issues)
  ;; (when (foldl (lambda (x y) (or x (list? (car y)))) ;; TODO refactor
  ;;              #f
  ;;              pattern)
  ;;   (set! pattern (map (lambda (x)
  ;;                        (if (list? (car x))
  ;;                            x
  ;;                            `(((,(car  x) ,(cadr x)))
  ;;                              #f
  ;;                              ,(caddr x)))) ; construct a 1-note chord
  ;;                      pattern)))

  (define samples-per-beat (/ (* fs 60) tempo))
  (array-append*
   (for*/list ([i    (in-range n)] ; repeat the whole pattern
               [note (in-list pattern)])
     (if (list? (car note)) ; chord
         (apply mix
                (map (lambda (x)
                    (list (sequence ;; TODO refactor
                            1
                            `((,(car x) ; note
                               ,(cadr x) ; octave
                               ,(caddr note))) ; duration
                             tempo function)
                          1)) ; all of equal weight
                  (car note)))
         (let ([f (if (car note)
                      (function (get-note-frequency (car note)
                                                    (cadr note)))
                      (lambda (x) 0))]) ; pause
           (build-array (vector (* samples-per-beat (caddr note))) f))))))
